import React from 'react';
import { fireEvent, render, waitFor } from '@testing-library/react-native';

// --- Mocks ---
const mockRecommendations = jest.fn();
jest.mock('../lib/api', () => ({
  apiClient: {
    recommendations: (...args: any[]) => mockRecommendations(...args),
  },
}));

jest.mock('@react-native-async-storage/async-storage', () =>
  require('@react-native-async-storage/async-storage/jest/async-storage-mock'),
);

import RecommendationsPage from '../../app/recommendations';

describe('RecommendationsPage', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders title and subtitle', () => {
    const { getByText } = render(<RecommendationsPage />);
    expect(getByText('AI Recommendations')).toBeTruthy();
    expect(getByText(/Ask questions about your customer segments/)).toBeTruthy();
  });

  it('renders the Generate Recommendation button', () => {
    const { getByText } = render(<RecommendationsPage />);
    expect(getByText('Generate Recommendation')).toBeTruthy();
  });

  it('renders suggested questions', () => {
    const { getByText } = render(<RecommendationsPage />);
    expect(getByText('What are the best segments for upselling?')).toBeTruthy();
    expect(getByText('How can we improve customer retention?')).toBeTruthy();
  });

  it('shows validation error when query is empty', async () => {
    const { getByText, getByPlaceholderText } = render(<RecommendationsPage />);
    fireEvent.changeText(
      getByPlaceholderText(/Ask about customer segments/),
      '',
    );
    fireEvent.press(getByText('Generate Recommendation'));

    await waitFor(() => {
      expect(getByText('Please enter a question')).toBeTruthy();
    });
  });

  it('calls apiClient.recommendations with the query on submit', async () => {
    mockRecommendations.mockResolvedValueOnce({
      recommendation: 'Focus on premium segments for upsell.',
      source: 'groq',
    });

    const { getByText } = render(<RecommendationsPage />);
    fireEvent.press(getByText('Generate Recommendation'));

    await waitFor(() => {
      expect(mockRecommendations).toHaveBeenCalledWith({
        query: 'What are the best segments for upselling?',
      });
    });
  });

  it('displays groq recommendation result', async () => {
    mockRecommendations.mockResolvedValueOnce({
      recommendation: 'Focus on premium segments for upsell.',
      source: 'groq',
    });

    const { getByText } = render(<RecommendationsPage />);
    fireEvent.press(getByText('Generate Recommendation'));

    await waitFor(() => {
      expect(getByText('Recommendation')).toBeTruthy();
      expect(getByText('Focus on premium segments for upsell.')).toBeTruthy();
      expect(getByText(/Generated by Groq AI/)).toBeTruthy();
    });
  });

  it('displays rule-based recommendation result', async () => {
    mockRecommendations.mockResolvedValueOnce({
      recommendation: 'Rule-based: prioritize C0/C2 for upsell.',
      source: 'rule_based',
    });

    const { getByText } = render(<RecommendationsPage />);
    fireEvent.press(getByText('Generate Recommendation'));

    await waitFor(() => {
      expect(getByText('Rule-based: prioritize C0/C2 for upsell.')).toBeTruthy();
      expect(getByText(/Generated from rule-based logic/)).toBeTruthy();
    });
  });

  it('shows error card on API failure (401 Unauthorized)', async () => {
    mockRecommendations.mockRejectedValueOnce(new Error('Unauthorized'));
    const { getByText } = render(<RecommendationsPage />);
    fireEvent.press(getByText('Generate Recommendation'));

    await waitFor(() => {
      expect(getByText('Unauthorized')).toBeTruthy();
    });
  });

  it('shows error card on network failure', async () => {
    mockRecommendations.mockRejectedValueOnce(new Error('Network request failed'));
    const { getByText } = render(<RecommendationsPage />);
    fireEvent.press(getByText('Generate Recommendation'));

    await waitFor(() => {
      expect(getByText('Network request failed')).toBeTruthy();
    });
  });

  it('shows error card on 503 Service Unavailable', async () => {
    mockRecommendations.mockRejectedValueOnce(new Error('Service Unavailable'));
    const { getByText } = render(<RecommendationsPage />);
    fireEvent.press(getByText('Generate Recommendation'));

    await waitFor(() => {
      expect(getByText('Service Unavailable')).toBeTruthy();
    });
  });

  it('shows generic error when error is not an Error instance', async () => {
    mockRecommendations.mockRejectedValueOnce('unexpected error');
    const { getByText } = render(<RecommendationsPage />);
    fireEvent.press(getByText('Generate Recommendation'));

    await waitFor(() => {
      expect(getByText('Recommendations failed')).toBeTruthy();
    });
  });

  it('updates query when a suggested question is pressed', () => {
    const { getByText, getByDisplayValue } = render(<RecommendationsPage />);
    fireEvent.press(getByText('How can we improve customer retention?'));
    expect(
      getByDisplayValue('How can we improve customer retention?'),
    ).toBeTruthy();
  });

  it('does not show result card before submitting', () => {
    const { queryByText } = render(<RecommendationsPage />);
    expect(queryByText('Recommendation')).toBeNull();
  });
});
